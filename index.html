<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VIBE</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Raleway:wght@400;700&family=Space+Grotesk:wght@400;700&family=Syne:wght@400;700;800&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #ffffff;
        --fg: #000000;
        --border: #000000;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: var(--bg);
        color: var(--fg);
        font-family: 'Syne', sans-serif;
        overflow: hidden;
      }

      .ui {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      .top-left {
        position: absolute;
        top: 20px;
        left: 24px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .top-right {
        position: absolute;
        top: 20px;
        right: 24px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 8px;
      }

      .label {
        font-size: 0.72rem;
        letter-spacing: 0.12em;
        font-weight: 700;
      }

      input[type='range'] {
        accent-color: var(--fg);
      }

      .vibe-select {
        width: 170px;
        background: var(--bg);
        color: var(--fg);
        border: 1px solid var(--border);
        font-family: inherit;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        padding: 7px 10px;
        text-transform: uppercase;
      }

      .space-slider {
        width: min(34vw, 260px);
      }

      .text-zone {
        position: absolute;
        left: 50%;
        top: 47%;
        transform: translate(-50%, -50%);
        width: min(88vw, 1200px);
        border-top: 1px solid var(--border);
        border-bottom: 1px solid var(--border);
        padding: 14px 0 10px;
      }

      .ticker-viewport {
        height: clamp(3.2rem, 9vw, 9rem);
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: flex-start;
      }

      .line-wrap {
        display: inline-block;
        transform: translateX(0);
        will-change: transform;
      }

      .line-wrap.idle-moving {
        animation: idle-marquee var(--idle-duration, 10s) linear infinite;
      }

      .ticker {
        display: inline-block;
        white-space: nowrap;
        font-size: clamp(3rem, 9vw, 9rem);
        line-height: 1;
        font-weight: 800;
        letter-spacing: -0.02em;
        transition: font-family 0.25s ease;
      }

      .ticker.is-placeholder {
        color: #b8b8b8;
      }

      .ticker.idle .line-text {
        animation: idle-breathe 2.4s ease-in-out infinite alternate;
      }

      .line-text {
        display: inline-block;
        padding-right: 0.08em;
      }

      .line-segment {
        display: inline-block;
      }

      .caret {
        display: none;
        width: 0.08em;
        height: 0.92em;
        margin-left: 0.04em;
        background: currentColor;
        vertical-align: baseline;
      }

      .caret.is-active {
        display: inline-block;
        animation: caret-blink 0.9s steps(1, end) infinite;
      }

      @keyframes caret-blink {
        0%,
        49% {
          opacity: 1;
        }
        50%,
        100% {
          opacity: 0;
        }
      }

      @keyframes idle-breathe {
        from {
          letter-spacing: -0.02em;
          opacity: 0.88;
        }
        to {
          letter-spacing: 0.005em;
          opacity: 1;
        }
      }

      @keyframes idle-marquee {
        from {
          transform: translateX(0);
        }
        to {
          transform: translateX(calc(-1 * var(--idle-shift, 0px)));
        }
      }

      .start-hint {
        margin: 12px 0 0;
        text-align: center;
        font-size: 0.72rem;
        letter-spacing: 0.12em;
        font-weight: 700;
        color: #9d9d9d;
        transition: opacity 0.2s ease;
      }

      .start-hint.is-hidden {
        opacity: 0;
      }

      .center-bottom {
        position: absolute;
        left: 50%;
        bottom: 34px;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 14px;
      }

      .volume-wrap {
        width: 54px;
        height: 190px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .volume-slider {
        width: 170px;
        transform: rotate(-90deg);
        transform-origin: center;
      }

      .bottom-btn {
        position: absolute;
        bottom: 24px;
        background: transparent;
        color: var(--fg);
        border: 1px solid var(--border);
        font-family: inherit;
        font-weight: 700;
        letter-spacing: 0.08em;
        font-size: 0.72rem;
        padding: 10px 14px;
        text-transform: uppercase;
        cursor: pointer;
      }

      .bottom-btn:hover {
        background: var(--fg);
        color: var(--bg);
      }

      .btn-left {
        left: 24px;
      }

      .btn-right {
        right: 24px;
      }

      .mobile-typing-proxy {
        position: fixed;
        left: -1000px;
        bottom: -1000px;
        width: 1px;
        height: 1px;
        opacity: 0;
        pointer-events: none;
      }

      @media (max-width: 768px) {
        .text-zone {
          top: 44%;
        }

        .top-right {
          top: 20px;
          right: 24px;
          left: auto;
          align-items: flex-end;
        }

        .space-slider {
          width: min(42vw, 220px);
        }

        .center-bottom {
          bottom: 110px;
        }
      }
    </style>
  </head>
  <body>
    <main class="ui">
      <section class="top-left" aria-label="Selector de vibe">
        <label class="label" for="vibe">VIBE</label>
        <select id="vibe" class="vibe-select">
          <option value="sine">CALMA</option>
          <option value="triangle">BRUMA</option>
          <option value="sawtooth">TENSIÓN</option>
          <option value="square">CRUDO</option>
        </select>
      </section>

      <section class="top-right" aria-label="Control de espacio">
        <label class="label" for="space">ESPACIO</label>
        <input id="space" class="space-slider" type="range" min="0" max="100" value="25" />
      </section>

      <section class="text-zone" aria-label="Frase principal">
        <div class="ticker-viewport">
          <div id="lineWrap" class="line-wrap">
            <div id="ticker" class="ticker is-placeholder idle">
              <span id="line" class="line-text"></span>
              <span id="caret" class="caret" aria-hidden="true"></span>
            </div>
          </div>
        </div>
        <p id="startHint" class="start-hint">ESCRIBE PARA INICIAR</p>
      </section>

      <section class="center-bottom" aria-label="Control de volumen">
        <div class="volume-wrap">
          <input id="volume" class="volume-slider" type="range" min="0" max="100" value="75" />
        </div>
        <label class="label" for="volume">VOLUMEN</label>
      </section>

      <button id="fontBtn" class="bottom-btn btn-left" type="button">TIPOGRAFÍA</button>
      <button id="newPhraseBtn" class="bottom-btn btn-right" type="button">NUEVA FRASE</button>
      <input
        id="mobileTypingProxy"
        class="mobile-typing-proxy"
        type="text"
        inputmode="text"
        autocomplete="off"
        autocorrect="off"
        autocapitalize="none"
        spellcheck="false"
        tabindex="-1"
        aria-hidden="true"
      />
    </main>

    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.js"></script>
    <script>
      const ticker = document.getElementById('ticker');
      const tickerViewport = document.querySelector('.ticker-viewport');
      const lineWrap = document.getElementById('lineWrap');
      const textZone = document.querySelector('.text-zone');
      const line = document.getElementById('line');
      const caret = document.getElementById('caret');
      const startHint = document.getElementById('startHint');
      const newPhraseBtn = document.getElementById('newPhraseBtn');
      const fontBtn = document.getElementById('fontBtn');
      const vibeSelect = document.getElementById('vibe');
      const spaceSlider = document.getElementById('space');
      const volumeSlider = document.getElementById('volume');
      const mobileTypingProxy = document.getElementById('mobileTypingProxy');
      const scaleNotes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4'];
      const fontModes = [
        {
          mood: 'EXPERIMENTAL',
          buttonLabel: 'TIPO: EXP',
          family: "'Syne', sans-serif",
          sound: { attack: 0.01, decay: 0.1, sustain: 0.25, release: 1.1, noteLength: '8n', transpose: 0, velocity: 0.85 }
        },
        {
          mood: 'CLASICA',
          buttonLabel: 'TIPO: CLAS',
          family: "'Playfair Display', serif",
          sound: { attack: 0.03, decay: 0.2, sustain: 0.35, release: 1.6, noteLength: '4n', transpose: -12, velocity: 0.75 }
        },
        {
          mood: 'TECHNO',
          buttonLabel: 'TIPO: TECH',
          family: "'Space Grotesk', sans-serif",
          sound: { attack: 0.002, decay: 0.08, sustain: 0.2, release: 0.45, noteLength: '16n', transpose: 12, velocity: 0.95 }
        },
        {
          mood: 'POP',
          buttonLabel: 'TIPO: POP',
          family: "'Raleway', sans-serif",
          sound: { attack: 0.008, decay: 0.12, sustain: 0.28, release: 0.9, noteLength: '8n', transpose: 0, velocity: 0.9 }
        }
      ];
      const suggestedPhrases = [
        'LA VIBRA ESTA EN EL AIRE',
        'TODO EMPIEZA CON UNA PALABRA',
        'DEJA QUE EL RITMO TE GUIE',
        'RESPIRA Y SIGUE ESCRIBIENDO',
        'HOY SUENA DISTINTO',
        'MANTEN LA ENERGIA ARRIBA'
      ];
      let currentSuggestion = '';
      let textRuns = [];
      let hasStartedTyping = false;
      let hasInteracted = false;
      let synth = null;
      let kickSynth = null;
      let drumGain = null;
      let drumLoop = null;
      let mixBus = null;
      let dryGain = null;
      let reverbFx = null;
      let audioReady = false;
      let audioStartPromise = null;
      let currentFontModeIndex = 0;
      let kickRootNote = 'C2';

      function getRandomSuggestion() {
        if (suggestedPhrases.length === 1) {
          return suggestedPhrases[0];
        }

        let next = suggestedPhrases[Math.floor(Math.random() * suggestedPhrases.length)];
        while (next === currentSuggestion) {
          next = suggestedPhrases[Math.floor(Math.random() * suggestedPhrases.length)];
        }
        return next;
      }

      function updateScrollToEnd() {
        lineWrap.classList.remove('idle-moving');
        lineWrap.style.removeProperty('--idle-shift');
        lineWrap.style.removeProperty('--idle-duration');
        const overflow = Math.max(0, lineWrap.scrollWidth - tickerViewport.clientWidth);
        lineWrap.style.transform = `translateX(${-overflow}px)`;
      }

      function updateIdleAnimation() {
        if (hasStartedTyping) {
          return;
        }

        const overflow = Math.max(0, lineWrap.scrollWidth - tickerViewport.clientWidth);
        if (overflow === 0) {
          lineWrap.classList.remove('idle-moving');
          lineWrap.style.removeProperty('--idle-shift');
          lineWrap.style.removeProperty('--idle-duration');
          lineWrap.style.transform = 'translateX(0)';
          return;
        }

        const shift = overflow + 24;
        const duration = Math.max(8, shift / 90);
        const nextShift = `${shift}px`;
        const nextDuration = `${duration}s`;
        if (lineWrap.style.getPropertyValue('--idle-shift') !== nextShift) {
          lineWrap.style.setProperty('--idle-shift', nextShift);
        }
        if (lineWrap.style.getPropertyValue('--idle-duration') !== nextDuration) {
          lineWrap.style.setProperty('--idle-duration', nextDuration);
        }
        if (!lineWrap.classList.contains('idle-moving')) {
          lineWrap.style.transform = 'translateX(0)';
          lineWrap.classList.add('idle-moving');
        }
      }

      function render() {
        line.textContent = '';
        const fragment = document.createDocumentFragment();
        for (const run of textRuns) {
          const segment = document.createElement('span');
          segment.className = 'line-segment';
          segment.style.fontFamily = hasStartedTyping ? fontModes[run.fontModeIndex].family : "'Syne', sans-serif";
          segment.textContent = run.text;
          fragment.appendChild(segment);
        }
        line.appendChild(fragment);
        ticker.classList.toggle('is-placeholder', !hasStartedTyping);
        caret.classList.toggle('is-active', hasStartedTyping);
        startHint.classList.toggle('is-hidden', hasInteracted);
        requestAnimationFrame(hasStartedTyping ? updateScrollToEnd : updateIdleAnimation);
      }

      function normalizeKeyToLetter(value) {
        if (!value || value.length !== 1) {
          return '';
        }

        return value
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '')
          .toLowerCase();
      }

      function setSynthVolume() {
        const amount = Number(volumeSlider.value);
        const decibels = -36 + amount * 0.36;
        if (synth) {
          synth.volume.value = decibels;
        }
        if (drumGain) {
          const drumLevel = 0.06 + (amount / 100) * 0.14;
          drumGain.gain.rampTo(drumLevel, 0.08);
        }
      }

      function setSpaceEffect() {
        if (!reverbFx || !dryGain) {
          return;
        }

        const amount = Number(spaceSlider.value) / 100;
        const wet = 0.02 + amount * 0.88;
        const decay = 0.9 + amount * 8.5;
        const dry = Math.max(0.55, 1 - amount * 0.35);
        reverbFx.decay = decay;
        reverbFx.wet.rampTo(wet, 0.1);
        dryGain.gain.rampTo(dry, 0.1);
      }

      function getDrumConfig(vibeType) {
        if (vibeType === 'triangle') {
          return { interval: '2n', pitch: 'G1', decay: 0.46, octaves: 2.2, velocity: 0.72 };
        }
        if (vibeType === 'sawtooth') {
          return { interval: '4n', pitch: 'C1', decay: 0.34, octaves: 3.1, velocity: 0.82 };
        }
        if (vibeType === 'square') {
          return { interval: '8n', pitch: 'A0', decay: 0.28, octaves: 3.6, velocity: 0.88 };
        }
        return { interval: '1n', pitch: 'C1', decay: 0.6, octaves: 1.8, velocity: 0.62 };
      }

      function applyDrumConfig() {
        if (!kickSynth || !drumLoop) {
          return;
        }

        const config = getDrumConfig(vibeSelect.value);
        kickSynth.set({
          pitchDecay: 0.02,
          octaves: config.octaves,
          envelope: { attack: 0.001, decay: config.decay, sustain: 0, release: 0.01 }
        });
        drumLoop.interval = config.interval;
      }

      function getCurrentFontMode() {
        return fontModes[currentFontModeIndex];
      }

      function applyFontMode(index) {
        currentFontModeIndex = (index + fontModes.length) % fontModes.length;
        const mode = getCurrentFontMode();
        fontBtn.textContent = mode.buttonLabel;
        fontBtn.title = `TIPOGRAFIA ${mode.mood}`;

        if (synth) {
          synth.set({
            envelope: {
              attack: mode.sound.attack,
              decay: mode.sound.decay,
              sustain: mode.sound.sustain,
              release: mode.sound.release
            }
          });
        }
      }

      function setRunsFromText(text) {
        textRuns = text ? [{ text, fontModeIndex: currentFontModeIndex }] : [];
      }

      function appendToRuns(char) {
        if (!char) {
          return;
        }

        const lastRun = textRuns[textRuns.length - 1];
        if (lastRun && lastRun.fontModeIndex === currentFontModeIndex) {
          lastRun.text += char;
          return;
        }

        textRuns.push({ text: char, fontModeIndex: currentFontModeIndex });
      }

      function removeLastRunChar() {
        if (textRuns.length === 0) {
          return false;
        }

        const lastRun = textRuns[textRuns.length - 1];
        lastRun.text = lastRun.text.slice(0, -1);
        if (lastRun.text.length === 0) {
          textRuns.pop();
        }
        return true;
      }

      function expandRunsToChars() {
        const chars = [];
        for (const run of textRuns) {
          for (const ch of run.text) {
            chars.push({ ch, fontModeIndex: run.fontModeIndex });
          }
        }
        return chars;
      }

      function compressCharsToRuns(chars) {
        const nextRuns = [];
        for (const item of chars) {
          const last = nextRuns[nextRuns.length - 1];
          if (last && last.fontModeIndex === item.fontModeIndex) {
            last.text += item.ch;
          } else {
            nextRuns.push({ text: item.ch, fontModeIndex: item.fontModeIndex });
          }
        }
        textRuns = nextRuns;
      }

      function getSelectionInLine() {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) {
          return null;
        }

        const range = sel.getRangeAt(0);
        if (!line.contains(range.startContainer) || !line.contains(range.endContainer)) {
          return null;
        }

        const before = range.cloneRange();
        before.selectNodeContents(line);
        before.setEnd(range.startContainer, range.startOffset);
        const start = before.toString().length;
        const end = start + range.toString().length;
        return { start, end, collapsed: range.collapsed };
      }

      function replaceRange(start, end, insertedText) {
        const chars = expandRunsToChars();
        const injected = [...insertedText].map((ch) => ({ ch, fontModeIndex: currentFontModeIndex }));
        chars.splice(start, end - start, ...injected);
        compressCharsToRuns(chars);
      }

      function selectAllLineText() {
        if (line.textContent.length === 0) {
          return;
        }
        const selection = window.getSelection();
        if (!selection) {
          return;
        }
        const range = document.createRange();
        range.selectNodeContents(line);
        selection.removeAllRanges();
        selection.addRange(range);
      }

      function startAudio() {
        if (audioReady) {
          return Promise.resolve();
        }

        if (audioStartPromise) {
          return audioStartPromise;
        }

        audioStartPromise = Tone.start()
          .then(() => {
            const mode = getCurrentFontMode();
            synth = new Tone.PolySynth(Tone.Synth, {
              oscillator: { type: vibeSelect.value },
              envelope: {
                attack: mode.sound.attack,
                decay: mode.sound.decay,
                sustain: mode.sound.sustain,
                release: mode.sound.release
              }
            });
            mixBus = new Tone.Gain(1);
            dryGain = new Tone.Gain(1).toDestination();
            reverbFx = new Tone.Reverb({ decay: 2.5, preDelay: 0.01, wet: 0.2 }).toDestination();
            mixBus.connect(dryGain);
            mixBus.connect(reverbFx);
            synth.connect(mixBus);
            drumGain = new Tone.Gain(0).connect(mixBus);
            kickSynth = new Tone.MembraneSynth().connect(drumGain);
            drumLoop = new Tone.Loop((time) => {
              const config = getDrumConfig(vibeSelect.value);
              const kickNote = kickRootNote || config.pitch;
              kickSynth.triggerAttackRelease(kickNote, '16n', time, config.velocity);
            }, '1n').start(0);
            applyDrumConfig();
            if (Tone.Transport.state !== 'started') {
              Tone.Transport.start();
            }
            setSpaceEffect();
            setSynthVolume();
            audioReady = true;
          })
          .catch(() => {})
          .finally(() => {
            audioStartPromise = null;
          });

        return audioStartPromise;
      }

      function playLetterSound(inputChar) {
        if (!audioReady || !synth) {
          return;
        }

        const normalized = normalizeKeyToLetter(inputChar);
        if (!/^[a-z]$/.test(normalized)) {
          return;
        }

        const mode = getCurrentFontMode();
        const isUpperCaseInput = inputChar === inputChar.toUpperCase() && inputChar !== inputChar.toLowerCase();
        const index = normalized.charCodeAt(0) - 97;
        let note = scaleNotes[index % scaleNotes.length];
        const totalTranspose = mode.sound.transpose + (isUpperCaseInput ? 12 : 0);
        if (totalTranspose !== 0) {
          note = Tone.Frequency(note).transpose(totalTranspose).toNote();
        }
        kickRootNote = Tone.Frequency(note).transpose(-24).toNote();
        const velocity = Math.min(1, mode.sound.velocity + (isUpperCaseInput ? 0.08 : 0));
        synth.triggerAttackRelease(note, mode.sound.noteLength, undefined, velocity);
      }

      function enterWritingMode(renderNow = true) {
        if (hasInteracted) {
          return false;
        }

        hasInteracted = true;
        hasStartedTyping = true;
        lineWrap.classList.remove('idle-moving');
        setRunsFromText('');
        if (renderNow) {
          render();
        }
        return true;
      }

      function isTouchKeyboardDevice() {
        return window.matchMedia('(pointer: coarse)').matches;
      }

      function focusMobileTypingProxy() {
        if (!isTouchKeyboardDevice()) {
          return;
        }
        mobileTypingProxy.focus({ preventScroll: true });
        mobileTypingProxy.value = '';
      }

      function resetPhraseState() {
        currentSuggestion = getRandomSuggestion();
        setRunsFromText(currentSuggestion);
        hasStartedTyping = false;
        hasInteracted = false;
        if (synth) {
          synth.releaseAll();
        }
        kickRootNote = 'C2';
        lineWrap.style.transform = 'translateX(0)';
        ticker.classList.add('idle');
        render();
      }

      newPhraseBtn.addEventListener('click', resetPhraseState);
      newPhraseBtn.addEventListener('pointerdown', (event) => event.preventDefault());
      textZone.addEventListener('click', () => {
        enterWritingMode();
        focusMobileTypingProxy();
      });
      vibeSelect.addEventListener('change', () => {
        if (synth) {
          synth.set({ oscillator: { type: vibeSelect.value } });
        }
        applyDrumConfig();
        vibeSelect.blur();
      });
      spaceSlider.addEventListener('input', setSpaceEffect);
      spaceSlider.addEventListener('change', () => spaceSlider.blur());
      volumeSlider.addEventListener('input', setSynthVolume);
      volumeSlider.addEventListener('change', () => volumeSlider.blur());

      fontBtn.addEventListener('pointerdown', (event) => event.preventDefault());
      fontBtn.addEventListener('click', () => {
        applyFontMode(currentFontModeIndex + 1);
        fontBtn.blur();
        requestAnimationFrame(updateScrollToEnd);
        focusMobileTypingProxy();
      });

      function handleBackspaceAction() {
        const isFirstInteraction = enterWritingMode(false);
        ticker.classList.remove('idle');
        const selected = getSelectionInLine();
        if (selected && selected.start !== selected.end) {
          replaceRange(selected.start, selected.end, '');
          render();
          return true;
        }

        if (textRuns.length === 0) {
          if (isFirstInteraction) {
            render();
          }
          return true;
        }

        removeLastRunChar();
        render();
        return true;
      }

      function handlePrintableKey(key) {
        if (key.length !== 1) {
          return false;
        }

        if (key === ' ') {
          enterWritingMode(false);
          ticker.classList.remove('idle');
          void startAudio();
          const selected = getSelectionInLine();
          if (selected) {
            replaceRange(selected.start, selected.end, ' ');
          } else {
            appendToRuns(' ');
          }
          render();
          return true;
        }

        const normalized = normalizeKeyToLetter(key);
        if (/^[a-z]$/.test(normalized)) {
          enterWritingMode(false);
          ticker.classList.remove('idle');
          const selected = getSelectionInLine();
          if (selected) {
            replaceRange(selected.start, selected.end, key);
          } else {
            appendToRuns(key);
          }
          render();
          if (audioReady) {
            playLetterSound(key);
          } else {
            void startAudio().then(() => {
              playLetterSound(key);
            });
          }
          return true;
        }

        enterWritingMode(false);
        ticker.classList.remove('idle');
        const selected = getSelectionInLine();
        if (selected) {
          replaceRange(selected.start, selected.end, key);
        } else {
          appendToRuns(key);
        }
        render();
        return true;
      }

      window.addEventListener('keydown', (event) => {
        if (event.repeat) {
          return;
        }

        if ((event.ctrlKey || event.metaKey) && !event.altKey) {
          if (event.key.toLowerCase() === 'a') {
            event.preventDefault();
            selectAllLineText();
          }
          return;
        }

        if (event.altKey) {
          return;
        }

        const target = event.target;
        if (target instanceof HTMLTextAreaElement || (target instanceof HTMLElement && target.isContentEditable)) {
          return;
        }
        if (target instanceof HTMLInputElement) {
          if (target === mobileTypingProxy) {
            return;
          }
          const textInputTypes = ['text', 'search', 'email', 'password', 'url', 'tel', 'number'];
          if (textInputTypes.includes(target.type)) {
            return;
          }
        }
        if (target instanceof HTMLSelectElement) {
          return;
        }

        if (event.key === 'Backspace') {
          event.preventDefault();
          handleBackspaceAction();
          return;
        }

        if (handlePrintableKey(event.key)) {
          return;
        }
      });

      mobileTypingProxy.addEventListener('keydown', (event) => {
        if (event.key === 'Backspace') {
          event.preventDefault();
          handleBackspaceAction();
        }
      });

      mobileTypingProxy.addEventListener('input', () => {
        if (!mobileTypingProxy.value) {
          return;
        }
        for (const ch of mobileTypingProxy.value) {
          handlePrintableKey(ch);
        }
        mobileTypingProxy.value = '';
      });

      window.addEventListener('resize', updateScrollToEnd);
      window.addEventListener('load', () => {
        applyFontMode(0);
        resetPhraseState();
      });
    </script>
  </body>
</html>
